/**
 * Document: MaxCompiler Tutorial (maxcompiler-tutorial)
 * Chapter: 3      Example: 1      Name: Moving Average Simple
 * MaxFile name: MovingAverageSimple
 * Summary:
 * 	Manager for the three point moving average kernel design.
 *  All IO is between the CPU and the DFE.
*/

package movingaveragesimple;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

import com.maxeler.maxcompiler.v2.build.EngineParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelConfiguration;
import com.maxeler.maxcompiler.v2.managers.custom.CustomManager;
import com.maxeler.maxcompiler.v2.managers.custom.DFELink;
import com.maxeler.maxcompiler.v2.managers.custom.blocks.KernelBlock;
import com.maxeler.maxcompiler.v2.managers.custom.stdlib.LMemCommandGroup;
import com.maxeler.maxcompiler.v2.managers.custom.stdlib.LMemInterface;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.CPUTypes;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.EngineInterface;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.EngineInterface.Direction;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceParam;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceParamArray;

/*
                File Structure

    1 - Global Variables
    	1.1 - Ids
    		1.1.1 - Layes
    		1.1.2 - LayerParams
    			1.1.2.1 - Act Funcs
    			1.1.2.2 - Pooling
    			1.1.2.3 - Error Funcs
    	1.2 - DFE Config
    		1.2.1 - Manager Design
    		1.2.2 - Kernel Design
    	1.3 - Computation
    	1.4 - Data Types
    	1.5 - Max Sizes
    	1.6 - Mem Control

    2 - Constructor

    3 - EngineInterfaces
    	3.1 - LMem
    		3.3.1 - Write
    		3.3.2 - Read
    	3.2 - Weights
    	3.3 - Propagation
    		3.3.1 - Forward
    		3.3.2 - Backward

    4 - ReadParams

    5 - Main

*/

class MovingAverageSimpleManager extends CustomManager
{
	// 1 --- Global Variables --- //

		// 1.1 --- IDs --- //

			// 1.1.1 --- Layers --- //

				private static final int Conv = 1;
				private static final int Pool = 2;
				private static final int Fcon = 3;

			// 1.1.2 --- Layer Params --- //

				// 1.1.2.1 --- Act Funcs --- //

					private static final int ReLu = 1;
					private static final int Sigmoid = 2;
					private static final int Tanh = 3;
					private static final int Soft = 4;

				// 1.1.2.2 --- Pool --- //

					private static final int MaxPool = 1;
					private static final int MeanPool = 2;

				// 1.1.2.3 --- Error Funcs --- //

					private static final int CrossEnt = 1;
					private static final int MSE = 2;

		// 1.2 --- Variables for DFE Configuration --- //

			// 1.2.1 --- Manager Design Params --- //

				private static int DesignFreq;				// Design Freq (MHz)
				private static int LMemFreq;				// LMem Access Freq (MHz)
				private static int Pipelining;				// Pipelining Level

			// 1.2.2 --- Kernel Design Params --- //

		// 1.3 --- Variables for Computation --- //

			private static int[] Layers;				// Layer Types
			private static int[][] Dims;				// Layer Dims [0] - Channels , [1] - Size
			private static double[][] Params;			// Layer Params
			private static int[] Parallelism;			// Layer Parallelism. 1 means BurstSize outputs are calculated at once. N means N*BurstSize outputs are calculated at once

			private static int BurstMult;				// DFE Burst Multiplier

			private static int WeightDims;				// Size Weight array will have

			private static int[] Padding;				// Amount of LMEM Padding input of each Layer has

		// 1.4 --- Data Types --- //

			private static final CPUTypes DataType = CPUTypes.DOUBLE;

		// 1.5 --- Max Sizes --- //

			private static final int MaxBlockSize = 20;	// Max Amount of Layers in a Block
			private static final int MaxParams = 5;		// Max Params a Layer can Have

		// 1.6 --- Mem Control --- //

			private static final int BurstSizeBytes = 192;												// Burst Size in Bytes, implicit for Galava DFE
			private static final int BurstSizeDataType = BurstSizeBytes/DataType.sizeInBytes(); 		// Burst Size in Doubles
			private static int OutputSizeBytes;															// Output Size in Bytes
			private static int OutputSizeDataType;														// Output Size in Doubles

	// 2 --- Manager Constructor --- //

		public MovingAverageSimpleManager(EngineParameters engineParams)
		{
			super(engineParams);

			// Setup Kernel and pass All Params
			KernelBlock K = addKernel(new MovingAverageSimpleKernel(makeKernelParameters("Kernel"),
																	Layers,
																	Dims, Params, Parallelism, Padding,
																	WeightDims,
																	BurstMult));

			// Lmem Interface
			LMemInterface LMem = addLMemInterface();

			// Streams from CPU to LMem and from LMem to CPU, to Write to LMem or Read from LMem
			DFELink cpu2lmem = LMem.addStreamToLMem("DataInWrite", LMemCommandGroup.MemoryAccessPattern.LINEAR_1D);
			DFELink lmem2cpu = LMem.addStreamFromLMem("DataOutRead", LMemCommandGroup.MemoryAccessPattern.LINEAR_1D);
			DFELink fromcpu = addStreamFromCPU("DataIn");
			DFELink tocpu = addStreamToCPU("DataOut");
			cpu2lmem <== fromcpu;
			tocpu <== lmem2cpu;

			// Linking Kernel Inputs and Outputs to LMem
			for(int Layer = 0; Layer < Layers.length; ++Layer)
			{
				// Inputs
				DFELink Input = LMem.addStreamFromLMem("Input" + Layer, LMemCommandGroup.MemoryAccessPattern.LINEAR_1D);
				K.getInput("Input" + Layer) <== Input;

				// Outputs
				DFELink Output = LMem.addStreamToLMem("Output" + Layer, LMemCommandGroup.MemoryAccessPattern.LINEAR_1D);
				Output <== K.getOutput("Output" + Layer);
			}
		}

	// 3 --- Engine Interfaces ---  //

		// 3.1 --- LMem --- //

			// 3.1.1 --- Write --- //

				private static EngineInterface InterfaceWrite()
				{
					EngineInterface Ei = new EngineInterface("MemWrite");

					// Params
					InterfaceParam Size  = Ei.addParam("Size", CPUTypes.INT32);			// Mem Size ( must be Padded Already)
					InterfaceParam Start = Ei.addParam("Start", CPUTypes.INT32);		// Where to start Writing

					// Set Streams
					Ei.setStream("DataIn", DataType, Size * DataType.sizeInBytes());										// Data to be Written
					Ei.setLMemLinear("DataInWrite", Start * DataType.sizeInBytes(), Size * DataType.sizeInBytes());			// Write Data

					// This shouldn't have to be here, but ignoreAll isn't working properly
					for(int i = 0; i < WeightDims; ++i)
					{
						Ei.setMem("Kernel", "Weights", i, (double) 0);
					}

					// Ignore Everything that's not used in this Interface
					Ei.ignoreAll(Direction.IN_OUT);

					return Ei;
				}

			// 3.1.2 --- Read --- //

				private static EngineInterface InterfaceRead()
				{
					EngineInterface Ei = new EngineInterface("MemRead");

					// Params
					InterfaceParam Size  = Ei.addParam("Size", CPUTypes.INT32);				// Mem Size ( must be Padded Already)
					InterfaceParam Start = Ei.addParam("Start", CPUTypes.INT32);			// Where to start Reading

					// Set Streams
					Ei.setStream("DataOut", DataType, Size * DataType.sizeInBytes());									// Data to be Read
					Ei.setLMemLinear("DataOutRead", Start * DataType.sizeInBytes(), Size * DataType.sizeInBytes());		// Read Data

					// This shouldn't have to be here, but ignoreAll isn't working properly
					for(int i = 0; i < WeightDims; ++i)
					{
						Ei.setMem("Kernel", "Weights", i, (double) 0);
					}

					// Ignore Everything that's not used in this Interface
					Ei.ignoreAll(Direction.IN_OUT);
					return Ei;
				}

		// 3.2 --- Weights --- //

			private static EngineInterface SetupWeights(boolean Conv, boolean Fcon)
			{
				// Logic to name Interfaces to Setup Both Weights at once, or 1 at a time
				String Name = "Setup";
				if(Conv & Fcon)
				{
					Name += "Weights";
				}
				else
				{
					if(Conv)
					{
						Name += "ConvWeights";
					}
					if(Fcon)
					{
						Name += "FconWeights";
					}
				}
				EngineInterface Ei = new EngineInterface(Name);

				/*
				// Setup Conv Weights
				if(Conv)
				{
					InterfaceParamArray ConvWeights = Ei.addParamArray("ConvWeights", CPUTypes.DOUBLE);		// Array Param
					Ei.setMem("Kernel", "ConvWeights", 0, ConvWeightsSize, ConvWeights);					// Setup FMem
				}

				// Setup FconWeights
				if(Fcon)
				{
					InterfaceParamArray FconWeights = Ei.addParamArray("FconWeights", CPUTypes.DOUBLE);		// Array Param
					Ei.setMem("Kernel", "FconWeights", 0, FconWeightsSize, FconWeights);					// Setup FMem
				}
				*/

				// Ignore Everything that's not used in this Interface
				Ei.ignoreAll(Direction.IN_OUT);

				return Ei;

			}

	// 3.3 --- Propagation --- //

		// 3.3.1 --- Forward --- //

			private static EngineInterface RunForward()
			{
				EngineInterface Ei = new EngineInterface("RunForward");

				// Amount of Ticks Kernel will run for
				InterfaceParam Ticks = Ei.addParam("Ticks", CPUTypes.UINT32);
				Ei.setTicks("Kernel", Ticks);

				// --------------------------------------------- //
				// ---------- 		Get Params 		   ----------//
				// --------------------------------------------- //

					// FMem with Weights
					InterfaceParamArray Weights = Ei.addParamArray("Weights", CPUTypes.DOUBLE);
					Ei.setMem("Kernel", "Weights", 0, WeightDims, Weights);

					// Enables
					InterfaceParamArray Enables = Ei.addParamArray("Enables", CPUTypes.UINT32);

					// First Output Points
					InterfaceParamArray FirstOutputs = Ei.addParamArray("FirstOutputs", CPUTypes.UINT32);

					// Pad Enables
					InterfaceParamArray PadEnables = Ei.addParamArray("PadEnables", CPUTypes.UINT32);

					// Parameter to control where bytes are written in memory
					InterfaceParamArray MemControl = Ei.addParamArray("MemControl", CPUTypes.UINT32);


				// --------------------------------------------- //
				// ---------- 		LayerSetup 		   ----------//
				// --------------------------------------------- //

					int MemStart = 0, TotalMemSize;
					for(int Layer = 0; Layer < Layers.length; ++Layer)
					{
						// Setup Enables

							Ei.setScalar("Kernel", "Enable" + Layer, Enables[Layer]);

						// Setup First Output Points

							Ei.setScalar("Kernel", "FirstOutput" + Layer, FirstOutputs[Layer]);

						// Setup Pad Enables

							Ei.setScalar("Kernel", "PadEnable" + Layer, PadEnables[Layer]);

						// Setup Mem Control

							Ei.setScalar("Kernel", "MemControl" + Layer, MemControl[Layer]);

						// Setup Inputs and Outputs for each Layers

							TotalMemSize = (Dims[Layer][0] * Dims[Layer][1] * Dims[Layer][1]) + Padding[Layer];
							TotalMemSize *= DataType.sizeInBytes();

							switch(Layers[Layer])
							{
								case Conv:
											// Input
											Ei.setLMemLinearWrapped("Input" + Layer,
																	Ei.addConstant(MemStart),
																	Ei.addConstant(TotalMemSize),
																	(Enables[Layer] > 0 ? 1 : 0) * ((2 * TotalMemSize) + OutputSizeBytes),
																	Ei.addConstant(0));

											MemStart += TotalMemSize;
											break;

								case Pool:
											// Input
											Ei.setLMemLinearWrapped("Input" + Layer,
																	Ei.addConstant(MemStart),
																	Ei.addConstant(TotalMemSize),
																	(Enables[Layer] > 0 ? 1 : 0) * (TotalMemSize + OutputSizeBytes),
																	Ei.addConstant(0));

											MemStart += TotalMemSize;
											break;
							}

							// Output
							Ei.setLMemLinear("Output" + Layer, MemStart + ( (MemControl[Layer]) * OutputSizeBytes), (Enables[Layer] > 0 ? BurstMult : 0) * BurstSizeBytes);
					}

					// Ignore Every Param not used here
					Ei.ignoreAll(Direction.IN_OUT);

				return Ei;
			}

		// 3.3.2 --- Backward --- //

			private static EngineInterface RunBackward()
			{
				EngineInterface Ei = new EngineInterface("Run");
				return Ei;

				/*
				// Setup Conv Weights
				InterfaceParamArray ConvWeights = Ei.addParamArray("ConvWeights", CPUTypes.DOUBLE);		// All Weights for all Conv Layers
				Ei.setMem("Kernel", "ConvWeights", 0, ConvWeightsSize, ConvWeights);					// Setup FMem

				// Setup Fcon Weights
				InterfaceParamArray FconWeights = Ei.addParamArray("FconWeights", CPUTypes.DOUBLE);		// All weights for all FCon Layers
				Ei.setMem("Kernel", "FconWeights", 0, FconWeightsSize, FconWeights);					// Setup FMem

				// Enables and Offsets
				InterfaceParamArray Enables = Ei.addParamArray("Enables", CPUTypes.UINT8);				// Which Layers Compute
				InterfaceParamArray Offsets = Ei.addParamArray("Offsets", CPUTypes.UINT32);				// Offsets for Where to write DataOut

				// Set Ticks
				Ei.setTicks("Kernel", TickMax);

				// Ignore All Params not Mentioned
				Ei.ignoreAll(Direction.IN_OUT);

				return Ei;
				*/
			}

	// 4 --- Read Params --- //

		private static void ReadParams()
		{
			try
			{

				// Read Layer File
				BufferedReader br;											// Reader to the File
				br = new BufferedReader(new FileReader("layers.txt"));		// Open Layer File
				String Line;												// Read Line
				String Aux[];												// Split the Line into all the values

				// Auxiliary Variables to read, so we can later
				// Call .length and get Correct Results with Real Variables
				int[] LayersAux = new int[MaxBlockSize];
				int[][] DimsAux = new int[MaxBlockSize][2];
				float[][] ParamsAux = new float[MaxBlockSize][MaxParams];
				int[] ParallelismAux = new int[MaxBlockSize];

				// Count number of Layers
				int LayerCount = 0;

			    while ((Line = br.readLine()) != null)
			    {
			    	Aux = Line.split(" ");
			    	LayersAux[LayerCount] = Integer.parseInt(Aux[0]);			// First Value is Layer Type
			    	ParallelismAux[LayerCount] = Integer.parseInt(Aux[1]);		// Second Value is Parallelism

			    	int i = 0;
			    	switch(LayersAux[LayerCount])
			    	{
			    		case 0:		// Block Output Dims + BurstMult
			    				DimsAux[LayerCount][0] = Integer.parseInt(Aux[1]);		// Channel
			    				DimsAux[LayerCount][1] = Integer.parseInt(Aux[2]);		// X
			    				BurstMult = Integer.parseInt(Aux[3]);					// Burst Multiplier

			    				OutputSizeDataType = BurstMult * BurstSizeDataType;
			    				OutputSizeBytes = OutputSizeDataType * DataType.sizeInBytes();
			    				break;

			    		case Conv:

			    				// Get Layer Params
			    				for(i = 0; i < 5; ++i)
			    				{
			    					ParamsAux[LayerCount][i] = Float.parseFloat(Aux[i + 2]);
			    				}

			    				// Input Dims for this Layer
			    				DimsAux[LayerCount][0] = Integer.parseInt(Aux[i+2]);
			    				DimsAux[LayerCount][1] = Integer.parseInt(Aux[i+3]);

			    				break;

			    		case Pool:

			    				// Get Layer Params
				    			for(i = 0; i < 4; ++i)
			    				{
			    					ParamsAux[LayerCount][i] = Float.parseFloat(Aux[i + 2]);
			    				}
				    			// Input Dims for this Layer
								DimsAux[LayerCount][0] = Integer.parseInt(Aux[i+2]);
								DimsAux[LayerCount][1] = Integer.parseInt(Aux[i+3]);

		    					break;

			    		case Fcon:

			    				// Get Layer Params
				    			for(i = 0; i < 2; ++i)
			    				{
			    					ParamsAux[LayerCount][i] = Float.parseFloat(Aux[i + 2]);
			    				}

				    			// Input Dims for this Layer
				    			DimsAux[LayerCount][0] = Integer.parseInt(Aux[i+2]);
				    			DimsAux[LayerCount][1] = Integer.parseInt(Aux[i+3]);
		    					break;
			    	}
			    	LayerCount++;		// Count Number of Layers

			    }

			    // Init in Proper Variables, now that we know layercount

				Layers = new int[LayerCount - 1];
				Dims = new int[LayerCount][2];
			    Params = new double[LayerCount - 1][MaxParams];
			    Parallelism = new int[LayerCount - 1];

				WeightDims = 0;

				Padding = new int[LayerCount - 1];

			    Dims[0][0] = DimsAux[0][0];
			    Dims[0][1] = DimsAux[0][1];

			    // Cycle to Copy Params. layercount - 1 Because of the extra Output Layer (0), that only has Output Dims
			    for(int i = 0; i < LayerCount - 1; i++)
			    {
			    	// Copy Layer Params
			    	for(int j = 0; j < MaxParams; j++)
			    	{
			    		Params[i][j] = ParamsAux[i][j];
			    	}

			    	// Copy Dims
			    	Dims[i + 1][0] = DimsAux[i + 1][0];
			    	Dims[i + 1][1] = DimsAux[i + 1][1];

			    	// Copy Layer Type and Parallelism
			    	Layers[i] = LayersAux[i];
			    	Parallelism[i] = ParallelismAux[i];

			    	switch(Layers[i])
			    	{
			    			case Conv:
										if((2 * Dims[i][0] * Params[i][2] * Params[i][2]) > WeightDims)
										{
											WeightDims = (int)(2 * Dims[i][0] * Params[i][2] * Params[i][2]);
										}
					    				break;

			    			case Pool :
					    				break;

			    			case Fcon:
										WeightDims += 0;
					    				break;
			    	}

			    	// Calculate Padding
			    	int TotalMemSize = (Dims[i][0] * Dims[i][1] * Dims[i][1]);
					if(TotalMemSize % OutputSizeDataType != 0)
					{
						Padding[i] = (OutputSizeDataType - (TotalMemSize % OutputSizeDataType));
					}
					else
					{
						Padding[i] = 0;
					}
			    }

			    br = new BufferedReader(new FileReader("params.txt"));
			    Aux = br.readLine().split(" ");
			    LMemFreq = Integer.parseInt(Aux[0]);
			    DesignFreq = Integer.parseInt(Aux[1]);
			    Pipelining = Integer.parseInt(Aux[2]);
			}
			catch (FileNotFoundException e)
			{

			}
			catch (IOException e)
			{

			}
		}

	// 5 --- Main --- //

		public static void main(String[] args)
		{
			ReadParams();

			EngineParameters params = new EngineParameters(args);
			MovingAverageSimpleManager m = new MovingAverageSimpleManager(params);

			// Set Pipelining
			KernelConfiguration currKConf = m.getCurrentKernelConfig();
			currKConf.optimization.setCEPipelining(Pipelining);
			//m.setCurrentKernelConfig(currKConf);

			// set clock frequency
			m.setDefaultStreamClockFrequency(DesignFreq);

			// Manager Configs

			// Create Interfaces
			m.createSlicInterface(SetupWeights(true, false));		// Setup Only Conv Weights
			m.createSlicInterface(SetupWeights(false, true));		// Setup Only Fcon Weights
			m.createSlicInterface(SetupWeights(true, true));		// Setup Both
			m.createSlicInterface(InterfaceWrite());				// Write to LMem
			m.createSlicInterface(InterfaceRead());					// Read to LMem
			m.createSlicInterface(RunForward());					// Run ForwardProp
			m.createSlicInterface(RunBackward()); 					// Run Backprop

			// Build Manager.
			m.build();
		}
}