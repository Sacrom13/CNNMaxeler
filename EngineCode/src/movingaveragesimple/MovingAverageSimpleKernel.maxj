/**
 * Document: MaxCompiler Tutorial (maxcompiler-tutorial)
 * Chapter: 3      Example: 1      Name: Moving Average Simple
 * MaxFile name: MovingAverageSimple
 * Summary:
 * 	Computes a three point moving average over the input stream
 */
package movingaveragesimple;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.WrapMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEFloat;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.CPUTypes;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

class MovingAverageSimpleKernel extends Kernel
{
	// 1 --- Global Variables --- //

		// 1.1 --- IDs --- //

			// 1.1.1 --- Layers --- //

				private static final int Conv = 1;
				private static final int Pool = 2;
				private static final int Fcon = 3;

			// 1.1.2 --- Layer Params --- //

				// 1.1.2.1 --- Act Funcs --- //

					private static final int ReLu = 1;
					private static final int Sigmoid = 2;
					private static final int Tanh = 3;
					private static final int Soft = 4;

				// 1.1.2.2 --- Pool --- //

					private static final int MaxPool = 1;
					private static final int MeanPool = 2;

				// 1.1.2.3 --- Error Funcs --- //

					private static final int CrossEnt = 1;
					private static final int MSE = 2;

		// 1.2 --- Data Types --- //

			private static final DFEFloat IODataType = dfeFloat(11, 53);			// Need to input/output as double and then cast to get correct results
			private static final DFEFloat ComputationDataType = dfeFloat(8, 24);	// Number precision used when doing calculation

			private static final CPUTypes DataType = CPUTypes.DOUBLE;

		// 1.3 --- Burst Size Settings --- //

			private static final int BurstSizeBytes = 192;												// Burst Size in Bytes, implicit for Galava DFE
			private static final int BurstSizeDataType = BurstSizeBytes/DataType.sizeInBytes();			// Burst Size in Doubles

	// 2 --- Constructor--- //

		MovingAverageSimpleKernel(KernelParameters parameters,
								int[] Layers,
								int[][] Dims, double[][] Params, int[] Parallelism, int[] Padding,
								int WeightDims,
								int BurstMult)
		{
			super(parameters);

			// TickCounter
			DFEVar TickCount = control.count.simpleCounter(32);

			// Get Weights
			Memory<DFEVar> Weights = mem.alloc(ComputationDataType, WeightDims);
			Weights.mapToCPU("Weights");

			int WeightBits = MathUtils.bitsToAddress(WeightDims);

			// Weight Offset
			DFEVar WeightArrayOffset = constant.var(0);

			// --------------------------------------------- //
			// ----------	  Layer Computation    ----------//
			// --------------------------------------------- //

			for(int Layer = 0; Layer < Layers.length; ++Layer)
			{
				// --------------------------------------------- //
				// ---------- 		Get Params 		   ----------//
				// --------------------------------------------- //

				// Get First Output Point

					DFEVar FirstOutput = io.scalarInput("FirstOutput" + Layer, dfeUInt(32));

				// Mem Control

					DFEVar MemControl = io.scalarInput("MemControl" + Layer, dfeUInt(32));

					//debug.simPrintf(TickCount.eq(0),"\tMemControl[%d] = %d\n", Layer, MemControl);

				switch(Layers[Layer])
				{
					case Conv:
								ConvForward(TickCount, Layer,
											Parallelism[Layer], Params[Layer], Padding[Layer],
											Dims[Layer], Dims[Layer + 1],
											BurstMult,
											Weights, WeightBits, WeightArrayOffset,
											MemControl, FirstOutput);

								WeightArrayOffset += ((MemControl > 0).cast(dfeUInt(16)) * 2 * Dims[Layer][0] * Params[Layer][2] * Params[Layer][2]);
								break;
					case Pool:
								if(Params[Layer][2] == MaxPool)
								{
									MaxPoolForward(TickCount, Layer,
													Parallelism[Layer], Params[Layer], Padding[Layer],
													Dims[Layer], Dims[Layer + 1],
													BurstMult,
													MemControl, FirstOutput);
								}
								else if(Params[Layer][2] == MeanPool)
								{
									MeanPoolForward(TickCount, Layer,
												Parallelism[Layer], Params[Layer], Padding[Layer],
												Dims[Layer], Dims[Layer + 1],
												BurstMult,
												MemControl, FirstOutput);
								}
								break;
					case Fcon:
								FconForward(TickCount, Layer,
											Parallelism[Layer], Params[Layer], Padding[Layer],
											Dims[Layer], Dims[Layer + 1],
											BurstMult,
											Weights, WeightBits, WeightArrayOffset,
											MemControl, FirstOutput);

								WeightArrayOffset += ((MemControl > 0).cast(dfeUInt(16)) * Math.pow(BurstMult*BurstSizeDataType,2));
								break;
				}
			}
		}

	// 3 --- Layer Computation --- //

		// 3.1 --- Conv --- //

			// 3.1.1 --- Forward --- //

				private void ConvForward(DFEVar TickCount, int Layer,
										 int Parallelism, double[] Params, int Padding,
										 int[] InDims, int[] OutDims,
										 int BurstMult,
										 Memory<DFEVar> Weights, int WeightBits, DFEVar WeightArrayOffset,
										 DFEVar Enable, DFEVar FirstOutput)
				{
					/* Params

						[0] = Act Func;
						[1] = NKernels;
						[2] = KernelSize;
						[3] = Stride;
						[4] = Padding;

						Burst size 3, BurstMult = 1, LayerPara = 2


										Input(4x3x3)

								x00 x01 x02		x09 x10 x11
								x03 x04 x05		x12 x13 x14
								x06 x07 x08		x15 x16 x17

								x18 x19 x20		x27 x28 x29
								x21 x22 x23		x30 x31 x32
								x24 x25 x26		x33 x34 x35


									4 Kernels(4x2x2)


								k00 k01		k04 k05						k16	k17		k20	k21
								k02 k03		k06	k07						k18	k19		k22	k23
					Kernel 1								Kernel 2
								k08	k09		k12	k13						k24	k25		k28	k29
								k10	k11		k14	k15						k26	k27		k30	k31



								k32 k33		k36 k37						k48	k49		k52	k53
								k34 k35		k38	k39						k50	k51		k54	k55
					Kernel 3								Kernel 4
								k40	k41		k44	k45						k56	k57		k60	k61
								k42	k43		k46	k47						k58	k59		k62	k63



					n				When to Output											First Output Point


					0			output on x09, x10 and x12.  									( 0 )
					1			output on tick x13, x(9 + 36) and x(10 + 36).  					( 3 )
					2			output on tick x12, x13, x(9 + 36).								( 2 )
					3			output on tick x10, x12, x13.									( 1 )
					4			output on tick x09, x10, x12									( 0 )
					5			output on tick x13, x14(pad), x15(pad)							( 3 )


						Only Output if:
										BurstSize * BurstMult * CurrentCall < NOutputPoints < BurstSize * BurstMult * (CurrentCall + 1)
										CTicks = InDims[0] / Parallelism			( Has to be Integer )
										YTicks <= OutDims[1
						 				XTicks <= OutDims[1]

						LMem Syncing takes precendence over Ticks.
						Need go make Ticks go through entire image and can't use controlled inputs in order for Stream.offset() to work properly

						Calculate the First Output Point, given by the following Formula (FirstOutputPoint[0] = 0):
						FirstOutputPoint[n] = (FirstOutputPoint[n - 1] + (BurstSize * BurstMult)) % (OutDims[1] * OutDims[1])

					*/

					// Helper Variables to avoid doing same computation more than once
					int PaddedInDims = (int) (InDims[1] + 2*Params[4]);
					int DFEStride = Params[3] > 1 ? (int) Params[3] : 2;

					// --------------------------------------------- //
					// ----------  Input Position Counters	---------//
					// --------------------------------------------- //

					// Input Padding ( LMem )		( Using Tick Count works since at most we only go through the Padding Zone Once!)
					DFEVar NotInputPadding = TickCount < InDims[0] * Math.pow(PaddedInDims, 2) | TickCount >= (InDims[0] * Math.pow(PaddedInDims, 2)) + Padding;

					// X
					Count.Params XParams = control.count.makeParams(MathUtils.bitsToAddress(PaddedInDims))
					.withMax(PaddedInDims)
					.withEnable(Enable > 0 & NotInputPadding);
					Counter XCounter = control.count.makeCounter(XParams);
					DFEVar XTicks = XCounter.getCount().cast(dfeUInt(16));

					// Y
					Count.Params YParams = control.count.makeParams(MathUtils.bitsToAddress(PaddedInDims))
					.withMax(PaddedInDims)
					.withEnable(Enable > 0 & XTicks.eq(PaddedInDims - 1) & NotInputPadding);
					Counter YCounter = control.count.makeCounter(YParams);
					DFEVar YTicks = YCounter.getCount().cast(dfeUInt(16));

					// Channels
					Count.Params CParams = control.count.makeParams(MathUtils.bitsToAddress(InDims[0]))
					.withMax(InDims[0])
					.withEnable(Enable > 0 & XTicks.eq(PaddedInDims - 1) & YTicks.eq(PaddedInDims - 1) & NotInputPadding);
					Counter CCounter = control.count.makeCounter(CParams);
					DFEVar CTicks = CCounter.getCount().cast(dfeUInt(16));

					// Kernel
					Count.Params KParams = control.count.makeParams(MathUtils.bitsToAddress(2))
					.withMax(2)
					.withEnable(Enable > 0 & CTicks.eq(InDims[0] - 1) & XTicks.eq(PaddedInDims - 1) & YTicks.eq(PaddedInDims - 1) & NotInputPadding);
					Counter KCounter = control.count.makeCounter(KParams);
					DFEVar KTicks = KCounter.getCount().cast(dfeUInt(16));

					// --------------------------------------------- //
					// ---------- 		Output Control		---------//
					// --------------------------------------------- //

					// X
					Count.Params XStrideParams = control.count.makeParams(MathUtils.bitsToAddress(DFEStride))
					.withMax(DFEStride)
					.withEnable(Enable > 0 & Params[3] > 1 & NotInputPadding & XTicks < PaddedInDims - Params[2]);
					Counter XStrideCounter = control.count.makeCounter(XStrideParams);
					DFEVar XStrideTicks = XStrideCounter.getCount().cast(dfeUInt(16));

					// Y
					Count.Params YStrideParams = control.count.makeParams(MathUtils.bitsToAddress(DFEStride))
					.withMax(DFEStride)
					.withEnable(Enable > 0 & Params[3] > 1 & XTicks.eq(PaddedInDims - 1) & NotInputPadding & YTicks < PaddedInDims - Params[2]);
					Counter YStrideCounter = control.count.makeCounter(YStrideParams);
					DFEVar YStrideTicks = YStrideCounter.getCount().cast(dfeUInt(16));

					// Check if Output Point or not
					DFEVar IsOutputPoint = Enable > 0 &
										   (XStrideTicks.eq(0) & YStrideTicks.eq(0) &	// Stride Control
										    CTicks.eq((InDims[0]/Parallelism) - 1) &	// If we are in last Computation Channel for a given Kernel
										    YTicks < PaddedInDims - Params[2] + 1 &		// If we are in correct Y position to Output
											XTicks < PaddedInDims - Params[2] + 1 );	// If we are in correct X position to Output

					// Padding
					DFEVar PadEnable = (Enable.eq(Math.ceil(OutDims[0] * OutDims[1] * OutDims[1]/ (float)(BurstMult*BurstSizeDataType))) & (TickCount > Padding + 2 * InDims[0] * PaddedInDims * PaddedInDims));
					IsOutputPoint |= PadEnable;

					// Output Points														2x Output size because of transitions
					Count.Params OutPointParams = control.count.makeParams(MathUtils.bitsToAddress(3 * OutDims[1] * OutDims[1] + (BurstSizeDataType * BurstMult)))
					.withMax(3 * OutDims[1] * OutDims[1] + (BurstSizeDataType * BurstMult) - 1)
					.withWrapMode(WrapMode.STOP_AT_MAX)
					.withInitValue(1)
					.withEnable((Enable > 0) & (IsOutputPoint));
					Counter OutPointCounter = control.count.makeCounter(OutPointParams);
					DFEVar OutPointTicks = OutPointCounter.getCount().cast(dfeUInt(32));

					DFEVar DataOutEnable =  (Enable > 0) &																											// If Layer is Active
											( (IsOutputPoint) & (OutPointTicks > FirstOutput) & (OutPointTicks < FirstOutput + 2 + (BurstSizeDataType*BurstMult)));	// Regular Output Point


					// --------------------------------------------- //
					// ---------- 		Input Control		---------//
					// --------------------------------------------- //

					DFEVar InPaddingZone = (Params[4] > 0) &
										   ( XTicks < Params[4] | XTicks > InDims[1] + Params[4] - 1 | YTicks < Params[4] | YTicks > InDims[1] + Params[4] - 1);

					DFEVar MemInput = io.input("Input" + Layer, IODataType, Enable > 0 & (InPaddingZone.eq(0) | NotInputPadding.eq(0)) & (TickCount < 2*(Padding + PaddedInDims*PaddedInDims*InDims[0])));

					DFEVar Input = InPaddingZone ? 0 : MemInput;

					// --------------------------------------------- //
					// ---------- 		Calc Output		   ----------//
					// --------------------------------------------- //

					DFEVar Output = constant.var(0);

					// Select Window
					for(int Channel = 0; Channel < InDims[0]; Channel += InDims[0] / Parallelism)
					{
						for(int y = 0; y < Params[2]; ++y)
						{
							for(int x = 0; x < Params[2]; ++x)
							{
								// Get Data Point

									// Calculate Offset of input data
									int DataOffset = (int) (Channel*Math.pow(PaddedInDims, 2) +  				// Channel
													 y * (PaddedInDims) +										// Line
												 	 x);														// Col

									// Read input data from LMem
									DFEVar Data = stream.offset(Input, DataOffset).cast(ComputationDataType);

								// Get Weight

									// Calculate Weight Offset
									DFEVar WeightOffset =  WeightArrayOffset + 											// Offset in Weight Array
														   (KTicks) * InDims[0] * Params[2] * Params[2] +				// Kernel
														   (CTicks + Channel) * Params[2] * Params[2] +					// Channel
													 	   y*Params[2] +												// Line
													 	   x;															// Col

									// Read Weight from FMem
									DFEVar Weight = Weights.read(WeightOffset.cast(dfeUInt(WeightBits))).cast(ComputationDataType);

								// Multiply and add to Output

									Output += Data * Weight;
							}
						}
					}

					// Carry Result to Next Channel
					DFEVar OutputCarry = ComputationDataType.newInstance(this);
					DFEVar OutputToAdd = CTicks.eq(0) ? 0 : OutputCarry;
					Output += OutputToAdd;
					OutputCarry <== stream.offset(Output, (int) (-Math.pow(PaddedInDims, 2)));

					// --------------------------------------------- //
					// ---------- 			Output		   ----------//
					// --------------------------------------------- //

					// Activation Function
					switch((int) Params[0])
					{
						case ReLu:
									Output = DataOutEnable ? (Output > 0 ? Output : 0) : Output;
									break;

						case Sigmoid:
									Output = DataOutEnable ? 1/( 1 + KernelMath.exp(-Output)) : Output;
									break;
						case Tanh:
									// No Direct function for tanh
									DFEVar aux = KernelMath.exp(2 * Output);
									Output = DataOutEnable ? (aux - 1) / (aux + 1) : Output;
									break;
					}

					// Output 0 if Padding
					Output = PadEnable ? 0 : Output;

					// Write Result to Mem
					io.output("Output" + Layer, Output.cast(IODataType), IODataType, DataOutEnable);

				}

			// 3.1.2 --- Backward --- //

				private void ConvBackward()
				{
				}

		// 3.2 --- Pool --- //

			// 3.2.1 --- Forward --- //

				private void MaxPoolForward(DFEVar TickCount, int Layer,
											 int Parallelism, double[] Params, int Padding,
											 int[] InDims, int[] OutDims,
											 int BurstMult,
											 DFEVar Enable, DFEVar FirstOutput)
				{
					/*
					[0] = Act;
					[1] = FilterSize;		// Pool Size : 2 means 2x2, 3 means 3x3, etc
					[2] = Type;				// Type: 1 - Max Pooling, 2 - Mean Pooling
					[3] = Stride;
					*/

					// Helper Variables to avoid doing same computation more than once
					int DFEStride = Params[3] > 1 ? (int) Params[3] : 2;

					// --------------------------------------------- //
					// ----------  Input Position Counters	---------//
					// --------------------------------------------- //

					// X
					Count.Params XParams = control.count.makeParams(MathUtils.bitsToAddress(InDims[1]))
					.withMax(InDims[1])
					.withEnable(Enable > 0);
					Counter XCounter = control.count.makeCounter(XParams);
					DFEVar XTicks = XCounter.getCount().cast(dfeUInt(16));

					// Y
					Count.Params YParams = control.count.makeParams(MathUtils.bitsToAddress(InDims[1]))
					.withMax(InDims[1])
					.withEnable(Enable > 0 & XTicks.eq(InDims[1] - 1));
					Counter YCounter = control.count.makeCounter(YParams);
					DFEVar YTicks = YCounter.getCount().cast(dfeUInt(16));

					// --------------------------------------------- //
					// ---------- 		Output Control		-------- //
					// --------------------------------------------- //

					// X
					Count.Params XStrideParams = control.count.makeParams(MathUtils.bitsToAddress(DFEStride))
					.withMax(DFEStride)
					.withEnable(Enable > 0 & Params[3] > 1 & XTicks < InDims[1] - Params[1]);
					Counter XStrideCounter = control.count.makeCounter(XStrideParams);
					DFEVar XStrideTicks = XStrideCounter.getCount().cast(dfeUInt(16));

					// Y
					Count.Params YStrideParams = control.count.makeParams(MathUtils.bitsToAddress(DFEStride))
					.withMax(DFEStride)
					.withEnable(Enable > 0 & Params[3] > 1 & XTicks.eq(InDims[1] - 1) & YTicks < InDims[1] - Params[1]);
					Counter YStrideCounter = control.count.makeCounter(YStrideParams);
					DFEVar YStrideTicks = YStrideCounter.getCount().cast(dfeUInt(16));

					// Check if Output Point or not
					DFEVar IsOutputPoint = 	Enable > 0 &
											(XStrideTicks.eq(0) & YStrideTicks.eq(0) &				// Stride Control
											YTicks < InDims[1] - Params[1] + 1 &					// If we are in correct Y position to Output
											XTicks < InDims[1] - Params[1] + 1);					// If we are in correct X position to Output

					// Padding
					DFEVar PadEnable = (Enable.eq(Math.ceil(OutDims[0] * OutDims[1] * OutDims[1]/ (float)(BurstMult*BurstSizeDataType))) & TickCount >= InDims[0] * InDims[1] * InDims[1]);

					IsOutputPoint |= PadEnable;


					// Output Points
					Count.Params OutPointParams = control.count.makeParams(MathUtils.bitsToAddress(OutDims[0] * OutDims[1] * OutDims[1] + BurstMult*BurstSizeDataType))
					.withMax(OutDims[0] * OutDims[1] * OutDims[1] + (BurstMult*BurstSizeDataType) - 1)
					.withWrapMode(WrapMode.STOP_AT_MAX)
					.withInitValue(1)
					.withEnable(Enable > 0 & IsOutputPoint);
					Counter OutPointCounter = control.count.makeCounter(OutPointParams);
					DFEVar OutPointTicks = OutPointCounter.getCount().cast(dfeUInt(32));

					DFEVar DataOutEnable =  (Enable > 0) &																												// If Layer is Active
											( (IsOutputPoint) & (OutPointTicks > FirstOutput) & (OutPointTicks < FirstOutput + 2 + (BurstSizeDataType*BurstMult)));		// Regular Output Point

					// --------------------------------------------- //
					// ---------- 		Input Control		-------- //
					// --------------------------------------------- //

					DFEVar Input = io.input("Input" + Layer, IODataType, Enable > 0 & (TickCount < InDims[0]*InDims[1]*InDims[1] + Padding));

					// --------------------------------------------- //
					// ---------- 		Calc Output		   ----------//
					// --------------------------------------------- //

					DFEVar Output = constant.var(-9999);

					// Select Window
					for(int y = 0; y < Params[1]; ++y)
					{
						for(int x = 0; x < Params[1]; ++x)
						{
							// Get Data Point

								// Calculate Offset of input data
								int DataOffset = y*InDims[1] +				// Line
											 	 x;							// Col

								// Read input data from LMem
								DFEVar Data = stream.offset(Input, DataOffset).cast(ComputationDataType);

							// Find Max

								Output = Output > Data ? Output : Data;
						}
					}

					// --------------------------------------------- //
					// ---------- 		Output		       ----------//
					// --------------------------------------------- //

					// Activation function
					switch((int) Params[0])
					{
						case ReLu:
									Output = DataOutEnable ? (Output > 0 ? Output : 0) : Output;
									break;

						case Sigmoid:
									Output = DataOutEnable ? 1/( 1 + KernelMath.exp(-Output)) : Output;
									break;
						case Tanh:
									// No Direct function for tanh
									DFEVar aux = KernelMath.exp(2 * Output);
									Output = DataOutEnable ? (aux - 1) / (aux + 1) : Output;
									break;
					}

					// Output 0 if Padding
					Output = PadEnable ? 0 : Output;

					// Output to Mem
					io.output("Output" + Layer, Output.cast(IODataType), IODataType, DataOutEnable);
				}

				private void MeanPoolForward(DFEVar TickCount, int Layer,
											 int Parallelism, double[] Params, int Padding,
											 int[] InDims, int[] OutDims,
											 int BurstMult,
											 DFEVar Enable, DFEVar FirstOutput)
				{
					/*
					[0] = Act;
					[1] = FilterSize;		// Pool Size : 2 means 2x2, 3 means 3x3, etc
					[2] = Type;				// Type: 1 - Max Pooling, 2 - Mean Pooling
					[3] = Stride;
					*/

					// Helper Variables to avoid doing same computation more than once
					int DFEStride = Params[3] > 1 ? (int) Params[3] : 2;

					// --------------------------------------------- //
					// ----------  Input Position Counters	---------//
					// --------------------------------------------- //

					// X
					Count.Params XParams = control.count.makeParams(MathUtils.bitsToAddress(InDims[1]))
					.withMax(InDims[1])
					.withEnable(Enable > 0);
					Counter XCounter = control.count.makeCounter(XParams);
					DFEVar XTicks = XCounter.getCount().cast(dfeUInt(16));

					// Y
					Count.Params YParams = control.count.makeParams(MathUtils.bitsToAddress(InDims[1]))
					.withMax(InDims[1])
					.withEnable(Enable > 0 & XTicks.eq(InDims[1] - 1));
					Counter YCounter = control.count.makeCounter(YParams);
					DFEVar YTicks = YCounter.getCount().cast(dfeUInt(16));

					// --------------------------------------------- //
					// ---------- 		Output Control		-------- //
					// --------------------------------------------- //

					// X
					Count.Params XStrideParams = control.count.makeParams(MathUtils.bitsToAddress(DFEStride))
					.withMax(DFEStride)
					.withEnable(Enable > 0 & Params[3] > 1 & XTicks < InDims[1] - Params[1]);
					Counter XStrideCounter = control.count.makeCounter(XStrideParams);
					DFEVar XStrideTicks = XStrideCounter.getCount().cast(dfeUInt(16));

					// Y
					Count.Params YStrideParams = control.count.makeParams(MathUtils.bitsToAddress(DFEStride))
					.withMax(DFEStride)
					.withEnable(Enable > 0 & Params[3] > 1 & XTicks.eq(InDims[1] - 1) & YTicks < InDims[1] - Params[1]);
					Counter YStrideCounter = control.count.makeCounter(YStrideParams);
					DFEVar YStrideTicks = YStrideCounter.getCount().cast(dfeUInt(16));

					// Check if Output Point or not
					DFEVar IsOutputPoint = 	Enable > 0 &
											(XStrideTicks.eq(0) & YStrideTicks.eq(0) &				// Stride Control
											YTicks < InDims[1] - Params[1] + 1 &					// If we are in correct Y position to Output
											XTicks < InDims[1] - Params[1] + 1);					// If we are in correct X position to Output

					// Padding
					DFEVar PadEnable = (Enable.eq(Math.ceil(OutDims[0] * OutDims[1] * OutDims[1]/ (float)(BurstMult*BurstSizeDataType))) & TickCount >= InDims[0] * InDims[1] * InDims[1]);

					IsOutputPoint |= PadEnable;


					// Output Points
					Count.Params OutPointParams = control.count.makeParams(MathUtils.bitsToAddress(OutDims[0] * OutDims[1] * OutDims[1] + BurstMult*BurstSizeDataType))
					.withMax(OutDims[0] * OutDims[1] * OutDims[1] + (BurstMult*BurstSizeDataType) - 1)
					.withWrapMode(WrapMode.STOP_AT_MAX)
					.withInitValue(1)
					.withEnable(Enable > 0 & IsOutputPoint);
					Counter OutPointCounter = control.count.makeCounter(OutPointParams);
					DFEVar OutPointTicks = OutPointCounter.getCount().cast(dfeUInt(32));

					DFEVar DataOutEnable =  (Enable > 0) &																												// If Layer is Active
											( (IsOutputPoint) & (OutPointTicks > FirstOutput) & (OutPointTicks < FirstOutput + 2 + (BurstSizeDataType*BurstMult)));		// Regular Output Point

					// --------------------------------------------- //
					// ---------- 		Input Control		-------- //
					// --------------------------------------------- //

					DFEVar Input = io.input("Input" + Layer, IODataType, Enable > 0 & (TickCount < InDims[0]*InDims[1]*InDims[1] + Padding));

					// --------------------------------------------- //
					// ---------- 		Calc Output		   ----------//
					// --------------------------------------------- //

					DFEVar Output = constant.var(0);

					// Select Window
					for(int y = 0; y < Params[1]; ++y)
					{
						for(int x = 0; x < Params[1]; ++x)
						{
							// Get Data Point

								// Calculate Offset of input data
								int DataOffset = y*InDims[1] +				// Line
											 	 x;							// Col

								// Read input data from LMem
								DFEVar Data = stream.offset(Input, DataOffset).cast(ComputationDataType);

							// Find Avg

								Output += Data;
						}
					}

					Output /= Params[1]*Params[1];

					// --------------------------------------------- //
					// ---------- 		Output		       ----------//
					// --------------------------------------------- //

					// Activation function
					switch((int) Params[0])
					{
						case ReLu:
									Output = DataOutEnable ? (Output > 0 ? Output : 0) : Output;
									break;

						case Sigmoid:
									Output = DataOutEnable ? 1/( 1 + KernelMath.exp(-Output)) : Output;
									break;
						case Tanh:
									// No Direct function for tanh
									DFEVar aux = KernelMath.exp(2 * Output);
									Output = DataOutEnable ? (aux - 1) / (aux + 1) : Output;
									break;
					}

					// Output 0 if Padding
					Output = PadEnable ? 0 : Output;

					// Output to Mem
					io.output("Output" + Layer, Output.cast(IODataType), IODataType, DataOutEnable);
				}

			// 3.2.2 --- Backward --- //

				private void PoolBackward()
				{

				}

		// 3.3 --- Fcon --- //

			// 3.2.1 --- Forward --- //

				private void FconForward(DFEVar TickCount, int Layer,
										 int Parallelism, double[] Params, int InputPadding,
										 int[] InDims, int[] OutDims,
										 int BurstMult,
										 Memory<DFEVar> Weights, int WeightBits, DFEVar WeightArrayOffset,
										 DFEVar Enable, DFEVar FirstOutput)
				{
					/*
					 [0] = ActFunc
					 [1] = DropP
					 */

					// --------------------------------------------- //
					// ---------- 			Counters 		---------//
					// --------------------------------------------- //

					// Output
					Count.Params OutputParams = control.count.makeParams(MathUtils.bitsToAddress(BurstSizeDataType * BurstMult))
					.withMax(BurstSizeDataType * BurstMult)
					.withEnable(Enable > 0);
					Counter OutputCounter = control.count.makeCounter(OutputParams);
					DFEVar OutputTicks = OutputCounter.getCount().cast(dfeUInt(16));

					// Input
					Count.Params InputParams = control.count.makeParams(MathUtils.bitsToAddress(BurstSizeDataType * BurstMult))
					.withMax(BurstSizeDataType * BurstMult)
					.withEnable(Enable > 0 & OutputTicks.eq(BurstSizeDataType * BurstMult - 1));
					Counter InputCounter = control.count.makeCounter(InputParams);
					DFEVar InputTicks = InputCounter.getCount().cast(dfeUInt(16));

					// --------------------------------------------- //
					// ---------- 		Output Control		---------//
					// --------------------------------------------- //

					// Check if Valid Output Point
					DFEVar DataOutEnable = Enable > 0 & InputTicks.eq((BurstSizeDataType * BurstMult/Parallelism) - 1);

					// Output Points
					Count.Params OutPointParams = control.count.makeParams(MathUtils.bitsToAddress(BurstMult * BurstSizeDataType))
					.withMax((BurstMult*BurstSizeDataType))
					.withWrapMode(WrapMode.STOP_AT_MAX)
					.withEnable(Enable > 0 & DataOutEnable);
					Counter OutPointCounter = control.count.makeCounter(OutPointParams);
					DFEVar OutPointTicks = OutPointCounter.getCount().cast(dfeUInt(32));

					DataOutEnable &= OutPointTicks < BurstMult*BurstSizeDataType;

					// --------------------------------------------- //
					// ---------- 		Input Control		---------//
					// --------------------------------------------- //

					DFEVar Input = io.input("Input" + Layer, IODataType, Enable > 0 & OutputTicks.eq(0) & (TickCount < Math.pow(BurstMult*BurstSizeDataType, 2) + InputPadding));

					// --------------------------------------------- //
					// ---------- 		Calc Output		   ----------//
					// --------------------------------------------- //

					DFEVar Output = constant.var(0);

					for(int CurIn = 0; CurIn < BurstSizeDataType * BurstMult; CurIn += BurstSizeDataType * BurstMult/Parallelism)
					{
						// Get Data Point

							// Calculate Offset of input data
							int DataOffset = CurIn * BurstSizeDataType * BurstMult;

							// Read input data from LMem
							DFEVar Data = stream.offset(Input, DataOffset).cast(ComputationDataType);

							// Get Weight

								// Calculate Weight Offset
								DFEVar WeightOffset = WeightArrayOffset + 											// Offset in WeightArray
													  (InputTicks + CurIn) * BurstSizeDataType * BurstMult +		// Input Offset
													  OutputTicks;													// Output Offset

							// Read Weight from FMem
							DFEVar Weight = Weights.read(WeightOffset.cast(dfeUInt(WeightBits))).cast(ComputationDataType);

						// Multiply and add to Output

							Output += Data * Weight;
					}

					// Carry Result to Next Inputs
					DFEVar OutputCarry = ComputationDataType.newInstance(this);
					DFEVar OutputToAdd = InputTicks > 0 ? OutputCarry : 0;
					Output += OutputToAdd;
					OutputCarry <== stream.offset(Output, -BurstSizeDataType * BurstMult);

					// Get the previous result already in memory
					DFEVar PrevOutput = io.input("PrevOutput" + Layer, IODataType, DataOutEnable);
					Output += DataOutEnable ? PrevOutput.cast(ComputationDataType) : 0;

					// --------------------------------------------- //
					// ---------- 		Output		       ----------//
					// --------------------------------------------- //

					int FirstOutputMax = InDims[0] > 1 ? InDims[0] * InDims[1] * InDims[1] : InDims[1];
					FirstOutputMax = (int) Math.floor((FirstOutputMax + InputPadding) / (float)(BurstMult*BurstSizeDataType));

					DFEVar ActEnable = DataOutEnable & FirstOutput.eq(FirstOutputMax);

					// Activation function
					switch((int) Params[0])
					{
						case ReLu:
									Output = ActEnable ? (Output > 0 ? Output : 0) : Output;
									break;

						case Sigmoid:
									Output = ActEnable ? 1/( 1 + KernelMath.exp(-Output)) : Output;
									break;
						case Tanh:
									// No Direct function for tanh
									DFEVar aux = KernelMath.exp(2 * Output);
									Output = ActEnable ? (aux - 1) / (aux + 1) : Output;
									break;
					}

					// Output to Mem
					io.output("Output" + Layer, Output.cast(IODataType), IODataType, DataOutEnable);
				}

			// 3.2.2 --- Backward --- //

				private void FconBackward()
				{
				}
}